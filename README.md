# TSP
分别用遗传算法、粒子群算法和蚁群算法解决34个省会城市的旅行商问题

### Contents
- [更新方式](#更新方式)
  - [遗传算法](#遗传算法更新方式)
  - [粒子群算法](#粒子群算法更新方式)
  - [蚁群算法](#蚁群算法更新方式)
- [收敛图](#收敛图)

#### 更新方式
##### 遗传算法更新方式
遗传算法经典的交叉是在两个不同的个体之间交换部分染色体，变异是在某个个体的某些位置的染色体突变。

而在 TSP 问题当中，由于某个城市只能出现一次，因此经典的做法在TSP 问题当中并不适用，因此本实验提出新的交叉和变异的操作。

选择操作：依旧采用轮盘赌法
新的交叉操作：以一定概率，对于某个个体的染色体的某两个位置进行交换，重复五次；
新的变异操作，以一定概率，对于某个个体的染色体的某两个位置进行交换。

##### 粒子群算法更新方式
经典的粒子速度更新公式如下：
<p align="center">𝑉𝑘+1 = 𝐶0𝑉𝑘 + 𝐶1(𝑝𝑏𝑒𝑠𝑡𝑘 − 𝑋𝑘) + 𝐶2(𝑔𝑏𝑒𝑠𝑡𝑘 − 𝑋𝑘)</p>

粒子位置更新公式如下：
<p align="center">𝑋𝑘+1 = 𝑋𝑘 + 𝑉𝑘+1</p>
其中，𝑋𝑘为粒子当前的位置，𝑉𝑘为当前的速度，𝑋𝑘+1为更新后的位置，𝑉𝑘+1为更新后的速度，pbest 为粒子本身所经历的最好位置，gbest 为群体中的最好位置，C0、C1、C2 分别为惯性因子，认知因子，社会因子。

应用粒子群算法解决 TSP 问题，用一个序列表示城市的访问顺序，粒子位置的更新表示从一种序列变为另一种。由于序列的复杂性，不能简单的使用上面的更新公式来更新，因此引入交换子和交换序列的概念。

交换子是交换序列某两个位置的元素，定义为 swap_x(x, i, j)。如 X=[1, 2, 3, 4, 5]，swap_x(X, 2, 4)即为交换 X 的第二和第四个元素，得到 X=[1, 4, 3, 2, 5]。

交换子序列是一系列交换子的集合，定义为 swap={swap_x(x, i, j), swap_x(x, m, n), ···}，对序列进行位置 i 元素和位置 j 元素交换。然后进行位置 m 元素和位置 n 元素交换，进行多次交换子操作。

重新定义粒子的速度和位置更新公式
<p align="center">𝑉𝑘+1 = 𝐶1(𝑝𝑏𝑒𝑠𝑡𝑘 − 𝑋𝑘) ∪ 𝐶2(𝑔𝑏𝑒𝑠𝑡𝑘 − 𝑋𝑘)</p>
<p align="center">𝑋𝑘+1 = 𝑋𝑘 + 𝑉𝑘+1</p>
其中，𝑝𝑏𝑒𝑠𝑡𝑘 − 𝑋𝑘表示一个交换子序列 swap1，使得𝑋𝑘经过 swap1 操作变成𝑝𝑏𝑒𝑠𝑡𝑘；𝑔𝑏𝑒𝑠𝑡𝑘 − 𝑋𝑘表示一个交换子序列 swap2，使得𝑋𝑘经过 swap2 操作变成𝑔𝑏𝑒𝑠𝑡𝑘；𝑉𝑘、𝑉𝑘+1分别是粒子当前和未来的交换子序列，即速度；𝑋𝑘和𝑋𝑘+1表示当前和未来的序列，𝑋𝑘 + 𝑉𝑘+1表示将𝑋𝑘经过交换子序列𝑉𝑘+1得到新的序列；C1、C2 分别为 0~1 的随机数，表示进行交换子序列操作的概率。
          
##### 蚁群算法更新方式
与遗传算法和粒子群算法不同，蚁群算法是专门用来解决 TSP 问题的启发式全局优化算法，不需要进行额外的变化。本实验中蚂蚁路径的选择采用轮盘赌法，信息素浓度采用Ant-Quantity 模型来模拟释放信息素的浓度。
          
#### 收敛图
<div align="center">
  <img src="https://github.com/Luxlios/Figure/blob/main/TSP/Figure_1.png" height="300">
</div>
<div align="center">
  <img src="https://github.com/Luxlios/Figure/blob/main/TSP/Figure_2.png" height="300">
</div>
<div align="center">
  <img src="https://github.com/Luxlios/Figure/blob/main/TSP/Figure_3.png" height="300">
</div>




          








